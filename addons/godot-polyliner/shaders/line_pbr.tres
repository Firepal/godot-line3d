[gd_resource type="Shader" format=3 uid="uid://c30na0obdky88"]

[resource]
code = "shader_type spatial;
render_mode skip_vertex_transform;
render_mode depth_draw_opaque;
render_mode alpha_to_coverage_and_one;

#include \"res://addons/godot-polyliner/shaders/include/polyliner_inc.gdshaderinc\"

uniform float line_width = 0.03;
uniform sampler2D width_curve : source_color;
uniform bool tangent_facing = false;
uniform bool rounded = false;
uniform bool uv_matches_width = true;

varying float is_end;
void vertex(){
	VERTEX = (MODELVIEW_MATRIX * vec4(VERTEX,1.0)).xyz;
	NORMAL = mat3(MODELVIEW_MATRIX) * NORMAL;
	TANGENT = mat3(MODELVIEW_MATRIX) * TANGENT;
	BINORMAL = mat3(MODELVIEW_MATRIX) * BINORMAL;
	
	LineData ld = pak_linedata(PLYLINE_INPUTS,line_width,rounded);
	is_end = line_process(ld);
	unpak_linedata(PLYLINE_INPUTS,ld);
	
//	BINORMAL = cross(TANGENT,NORMAL);
	
	if (uv_matches_width) {
		UV.x /= line_width;
	}
	
	UV.x = 1.0-UV.x;
	
	float line_length = UV2.x;
	UV2 = UV;
	UV2.x *= line_length;
	
	if (rounded) {
		float uv_correct = is_end*line_width;
		UV.x += uv_correct;
		UV2.x += uv_correct;
	}
}

uniform sampler2D texture_alb : hint_default_white, source_color;
uniform sampler2D texture_rgh : hint_default_white;
uniform bool tex_stretch = true;
uniform vec2 tex_scale = vec2(1.0,1.0);

uniform vec4 color : source_color = vec4(vec3(1.0),1.0);
uniform float metallic  : hint_range(0.0,1.0,0.005) = 0.0;
uniform float specular  : hint_range(0.0,1.0,0.005) = 0.5;
uniform float roughness : hint_range(0.0,1.0,0.005) = 0.5;

uniform bool tube_normal = true;
void fragment() {
	if (!FRONT_FACING) { NORMAL = -NORMAL; }
	
	if (tube_normal && !tangent_facing) { 
		NORMAL_MAP = getLineTubeNormal(UV,is_end,rounded);
	}
	
	
	if (rounded && abs(is_end) > 0.0) {
		const float magic = pow(500.0,2.0); // looks reasonably good
		float softner = (VERTEX.z*magic) / dot(VIEWPORT_SIZE,VIEWPORT_SIZE);
		softner *= abs(is_end);
		ALPHA *= smoothstep(1.0,1.0+softner,getDistToLineCenter(UV,is_end)*4.0);
	}
	
	vec2 uv_alb = UV2;
	if (tex_stretch) {
		uv_alb = UV;
	}
	uv_alb *= tex_scale;
	
	vec4 alb_sample = texture(texture_alb,uv_alb.yx);
	vec4 rgh_sample = texture(texture_rgh,uv_alb.yx);
	
	ALBEDO = alb_sample.rgb * alb_sample.a * color.rgb;
	SPECULAR = specular;
	ROUGHNESS = roughness * rgh_sample.r;
	METALLIC = metallic;
	
	ALPHA_SCISSOR_THRESHOLD = 0.001; // uncomment for alpha blending
}"
